# 算法基础

# 算法概念

# 时间复杂度
> 用来评估算法运行效率的一个式子

如何快速判断算法复杂度

- 确定问题规模n
- 循环减半过程 -> log n
- k 层关于n的循环 -> n的k次方

# 空间复杂度
> 用来评估算法内存占用大小的式子

空间复杂度的表示方式与时间复杂度完全一样

- 算法使用了几个变量 O(1)
- 算法使用了长度为n的一维列表 O(n)
- 算法使用了m行n列的二维列表 O(mn)

# 递归的两个特点

- 调用自身
- 结束条件

# 查找
> 在一些数据元素中，通过一定的方法找出给定关键字相同的数据元素的过程

# 列表查找（线性查找）：从列表中查找指定元素
- 输入：列表、待查找元素
- 输出：元素下标（未找到元素时一般返回None或-1）
- 内置列表查找函数:index()

# 二分查找(Binary Search)
> 又叫折半查找，从有序列表的初始候选区li[0:n]开始，通过对待查找的值与候选区中间值的比较，可以使选区减少一半

# 排序

# 快速排序
- 取一个元素（第一个元素），使元素p归位
- 列表被p分成两部分，左边都比p小，右边都比p大
- 递归完成排序

# 堆排序

堆排序前传-树与二叉树

- 满二叉树
> 一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树

- 完全二叉树
> 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树

二叉树的存储方式

- 链式存储方式
- 顺序存储方式

# 堆
> 一种特殊的完全二叉树结构

- 大根堆
> 一颗完全二叉树，满足任一节点都比其孩子节点大
- 小根堆
> 一颗完全二叉树，满足任一节点都比其孩子节点小

堆排序的过程

- 1、建立堆
- 2、得到堆顶元素，为最大元素
- 3、去堆顶元素，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序
- 4、堆顶元素为第二个元素
- 5、重复步骤3，直到堆变空

挨个出数

时间复杂度nlogn

*python中内置堆排序*
> heapq

# 堆排序---topk问题
> 现在有n个数，设计算法得到前k大的数

**O(nlogk)**

- 取列表前k个袁术建立一个小根堆。堆顶就是目前第k大的数
- 依次向后遍历原列表，对于列表中的元素，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素，并且对堆进行一次调整
- 遍历弹出

# 列表
- 列表在py中是顺序存储的
